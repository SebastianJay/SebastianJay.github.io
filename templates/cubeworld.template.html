<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="webgl-utils.js"></script>

<script type="text/javascript" src="map_builder.js"></script>
<script type="text/javascript" src="input_handler.js"></script>
<script type="text/javascript" src="colliding.js"></script>
<script type="text/javascript" src="collectibles.js"></script>
<script type="text/javascript" src="lighting.js"></script>
<script type="text/javascript" src="special_primitives.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec2 vTextureCoord;
  varying vec3 vLightWeighting;

  uniform sampler2D uSampler;

  void main(void) {
	vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
      //gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
      gl_FragColor = vec4(textureColor.rgb * vLightWeighting, textureColor.a);
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
	uniform mat3 uNMatrix;

	uniform vec3 uAmbientColor;

	uniform vec3 uLightingDirection;
	uniform vec3 uDirectionalColor;

	uniform vec3 uPointLightingPosition;
	uniform vec3 uPointLightingColor;

	uniform bool uUseLighting;

  varying vec2 vTextureCoord;
	varying vec3 vLightWeighting;

  void main(void) {
		vec4 mvPosition = uMVMatrix * vec4(aVertexPosition, 1.0);
		vec4 pointLightPos = uMVMatrix * vec4(uPointLightingPosition, 1.0);
    gl_Position = uPMatrix * mvPosition;
    vTextureCoord = aTextureCoord;

		if (!uUseLighting) {
			vLightWeighting = vec3(1.0, 1.0, 1.0);
		} else {
			vec3 transformedNormal = uNMatrix * aVertexNormal;
			vec3 pointLightDir = normalize(pointLightPos.xyz - mvPosition.xyz);
			float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
			float pointLightWeighting = max(dot(transformedNormal, pointLightDir), 0.0);
			vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting + uPointLightingColor * pointLightWeighting;
		}
  }
</script>

<link rel="stylesheet" href="cubeworld.css">

<script type="text/javascript" src="init.js"></script>

<div id="gl-container">
  <canvas id="gl-canvas" width="1280" height="720"></canvas>
  <div id="health-text" class="canvas-text"></div>
  <div id="endgame-text" class="canvas-text"></div>
</div>

<br/>
<br/>

<div class="text-center">
  <a data-toggle="collapse" href="#build-info" aria-expanded="false" aria-controls="build-info">
    Toggle Info
  </a>
</div>

<div id="build-info" class="collapse">
  <div class="card card-block">
    <h3>Overview</h3>
    <p>The objective of this small walking simulator is to collect the 6 colored spheres
      located on the inside of the cube. You may switch sides on the cube by approaching a
      wall and jumping. Each surface has its own theme and hazards. Enjoy!</p>

    <h3>Controls</h3>
    <p>The first set of keybindings is recommended as it will not scroll the page.</p>
    <ul>
      <li>A/D or Left/Right: Rotate left/right</li>
      <li>W/S or Up/Down: Move forward/backward</li>
      <li>Q/E or PgUp/PgDn: Look up/down</li>
      <li>P or Space: Jump</li>
    </ul>
  </div>
</div>
